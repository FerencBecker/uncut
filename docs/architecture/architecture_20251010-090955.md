**ARCHITECTURE SUMMARY**

### 1. System Approach
**Architecture Pattern**: Backend-for-Frontend (BFF) with shared data layer - enables unified JSON schema supporting both offline kiosk and online web platform with component reusability
**Technology Categories**: .NET 10.0 backend + React 18 TypeScript frontend + JSON/SQLite data layer - latest LTS with performance improvements and native AOT support for museum applications
**Component Organization**: Dual BFF services (lightweight kiosk, full-featured web) consuming identical API contracts from shared JSON data structures with platform-specific optimizations

### 2. Phase Evolution Strategy
**Phase 1 (Kiosk)**: Docker containerized .NET mini-BFF serving static JSON files to React touch interface - simple offline operation with autonomous restart capabilities
**Phase 2 (Web)**: Enhanced .NET BFF with MuseumPlus API integration, write-through caching, and SQLite search indexing - adds horizontal scaling and CMS capabilities
**Long-term**: Modular architecture enables independent platform scaling, easy technology upgrades, and cost-effective hosting migration without architectural changes

### 3. System Structure
```
┌─────────────────┐    ┌─────────────────────────────────────┐
│   KIOSK APP     │    │           WEB PLATFORM              │
│   (React TS)    │    │          (React TS)                 │
│        │        │    │               │                     │
│   BFF-Mini      │    │           Web BFF                   │
│   (.NET 10)     │    │         (.NET 10)                   │
│        │        │    │        /          \                 │
│   JSON Files    │    │  JSON Cache    MuseumPlus API       │
│  (filesystem)   │    │ (filesystem)   (External)           │
└─────────────────┘    └─────────────────────────────────────┘
```

### 4. Key Architectural Decisions
**Decision 1**: .NET 10.0 ASP.NET Core backend - Latest LTS with support through 2027, excellent JSON handling with System.Text.Json improvements, native AOT compilation support for reduced memory footprint, enhanced ARM64 performance for Raspberry Pi deployment - Trade-off of preview version adoption (until November 2025 GA) for modern features and extended support timeline
**Decision 2**: React 18 TypeScript frontend - Component reusability between platforms, sophisticated animation capabilities (Framer Motion), type safety - Trade-off of learning curve for proven cultural heritage application framework
**Decision 3**: JSON filesystem + SQLite hybrid storage - Entity-level JSON files (one studio = one file, one image = one file) serve as primary data storage, SQLite FTS5 provides complementary search indexing for web platform only - Enables pure offline kiosk operation while providing <1 second web search queries - Trade-off of dual storage complexity for platform-specific optimization
**Decision 4**: Multi-architecture Docker deployment - Single codebase supporting Raspberry Pi 5 ARM64 and PC x64 with automated CI/CD - Trade-off of container overhead for deployment consistency and hardware flexibility

### 5. System Behavior Requirements
**Data Consistency**: Write-through caching with atomic JSON file updates and TTL-based cache invalidation - MuseumPlus API serves as source of truth with local filesystem providing offline resilience - Cache TTL configurable per entity type (default: 24 hours for studios, 1 hour for images), background refresh optional - Primary technology: .NET file I/O with temp-to-rename strategy
**Error Recovery**: Tiered fallback system with circuit breaker patterns - Kiosk operates independently, web serves cached content during API unavailability - Recovery technology: Polly retry policies with exponential backoff
**Audit & Compliance**: GDPR-compliant analytics and content access logging - 7-year retention for cultural heritage compliance - Google Analytics with consent management stored in SQLite audit tables
**Performance Expectations**: <2 second page loads, <200ms touch response, 100+ concurrent web users, <1 second search queries - Memory caching and CDN optimization for global image delivery - Horizontal scaling through load-balanced stateless .NET BFF instances with shared filesystem cache storage (NFS/Azure Blob Storage/AWS S3) for cache consistency across nodes
**Monitoring & Observability**: Minimum metrics tracking includes cache hit rate, MuseumPlus API latency, error rates, and request throughput - Technology choice configurable: ELK Stack (Elasticsearch/Logstash/Kibana), OpenTelemetry with Grafana, or Azure Application Insights depending on hosting environment - Structured logging with correlation IDs for distributed tracing across BFF instances

### 6. Integration & Extensibility
**System Boundaries**: MuseumPlus API integration with fallback caching, React Admin CMS for content management, email integration for visitor inquiries - HTTP REST protocols with bearer token authentication
**Extension Points**: Plugin architecture for additional content types, modular animation system for performance adaptation, configurable hosting options - React component composition and .NET dependency injection patterns
**Data Exchange**: Versioned JSON schema (semantic versioning) with bilingual content structure enabling backward-compatible field additions, image metadata with academic citation formats, Excel import pipeline - RESTful APIs with OpenAPI documentation for future integrations - Schema evolution supports new content types without breaking existing kiosk/web clients

### 7. Architectural Constraints & Assumptions
**System Boundaries**: Handles photo studio archive presentation and visitor interaction - does not manage physical collections, financial transactions, or complex user management beyond content editing roles
**Growth Assumptions**: 3000+ images expanding annually, peak 100+ concurrent web users, continuous 24/7 kiosk operation - architecture scales horizontally for web traffic and maintains offline reliability for exhibition use
**Technology Constraints**: Must support Raspberry Pi 5 ARM64 and legacy PC x64, integration with existing MuseumPlus system, limited post-launch support requiring maintainable technology choices

### 8. Testing Strategy
**Unit Testing Approach**: xUnit for .NET backend and Jest + React Testing Library for frontend - 95% coverage organized by feature slices within technical boundaries - Mock at API/database interfaces using Test Containers for integration testing
**E2E Testing Approach**: Playwright for cross-browser automation testing critical user journeys - 60-80% coverage of complete workflows from map interaction through image viewing - Test environment mirrors production with sample cultural heritage data
**Test Organization**: Vertical slice testing within frontend/backend layers, shared component testing across platforms, hardware-specific testing for touch interfaces - Agent-driven test automation with clear boundary definitions
**CI/CD Integration**: GitHub Actions pipeline with automated testing gates, multi-architecture Docker builds, blue-green deployment with automatic rollback capabilities - All tests must pass before deployment to prevent exhibition disruption

### 9. Implementation Details

#### 9.1 BFF-Mini Project Structure
```
backend/BffMini/
├── BffMini.csproj                   # .NET 10.0 project file with minimal dependencies
├── Program.cs                        # Minimal API entry point with middleware configuration
├── Dockerfile                        # Multi-architecture Docker build configuration
├── .dockerignore                     # Docker build exclusions
├── appsettings.json                  # Base configuration
├── appsettings.Development.json      # Development environment settings
├── appsettings.Production.json       # Production environment settings
├── Repositories/
│   ├── IStudioRepository.cs         # Studio data access abstraction
│   ├── IImageRepository.cs          # Image data access abstraction
│   ├── StudioRepository.cs          # File-based studio repository implementation
│   └── ImageRepository.cs           # File-based image repository implementation
├── Endpoints/
│   ├── StudiosEndpoints.cs          # Studio API endpoints (GET /api/studios, /api/studios/{id})
│   └── ImagesEndpoints.cs           # Image API endpoints (GET /api/images, /api/images/{id})
├── Models/
│   ├── Studio.cs                    # Studio entity model
│   ├── Image.cs                     # Image entity model
│   ├── Location.cs                  # Geographic location model
│   ├── BilingualText.cs             # Bilingual text support
│   └── Manifest.cs                  # Image ordering manifest
└── Extensions/
    └── ServiceCollectionExtensions.cs # Dependency injection configuration

backend/BffMini.Tests/
├── BffMini.Tests.csproj             # xUnit test project
├── Models/
│   └── ModelSerializationTests.cs   # Model serialization/deserialization tests
├── Repositories/
│   ├── StudioRepositoryTests.cs     # Unit tests with file system mocking
│   └── ImageRepositoryTests.cs      # Unit tests with file system mocking
└── Integration/
    └── ApiIntegrationTests.cs       # Integration tests using WebApplicationFactory
```

#### 9.2 Data Access Layer Architecture

**Repository Pattern**: Business-focused data access abstraction separating API endpoints from storage implementation details

**Layering:**
```
API Endpoints (REST operations: GET /api/studios?city=Dombovár)
    ↓
Repository Layer (business operations: GetAllStudios, GetStudiosByCity)
    ↓
File System (JSON files: data/studios/{id}.json)
```

**Phase 1 (Kiosk)**: Repository reads from manually curated JSON files on disk
**Phase 2 (Web)**: Repository reads from identical JSON files synchronized from MuseumPlus API
**Key Insight**: Same repository implementation serves both phases - only the source of JSON files changes

**Repository Responsibilities:**
- Load and deserialize JSON files into business objects (Studio, Image)
- Query and filter business objects (by city, by region, by date)
- Return business objects to API endpoints
- Handle file-not-found scenarios gracefully

#### 9.3 Dependency Injection Configuration
**Service Registration Pattern**: Extension method pattern in `ServiceCollectionExtensions.cs` provides clean separation of concerns and testability
- **IStudioRepository**: Registered as singleton - stateless design enables concurrent access
- **IImageRepository**: Registered as singleton - stateless design enables concurrent access
- **JsonSerializerOptions**: Registered as singleton with camelCase policy for consistent JSON handling
- **HTTP Context Accessor**: Registered for correlation ID propagation through request pipeline

**Configuration Binding**: Uses IOptions<T> pattern for strongly-typed configuration with validation support - enables runtime configuration reloads without application restart

#### 9.4 Logging Configuration and Correlation IDs
**Structured Logging**: Serilog configured with console and file sinks for comprehensive observability
- **Console Sink**: Formatted output for Docker container log aggregation with timestamp and log level
- **File Sink**: Rolling daily logs in logs/ directory with 30-day retention for troubleshooting
- **Enrichment**: FromLogContext + CorrelationId enricher automatically injects correlation IDs into all log entries

**Correlation ID Implementation**:
- **Source**: Uses HttpContext.TraceIdentifier as correlation ID - automatically generated per request by ASP.NET Core
- **Propagation**: Serilog request logging middleware enriches diagnostic context with CorrelationId property
- **Response Headers**: Correlation ID available in logs for request/response tracing and distributed system debugging
- **ApiResponse Model**: Includes CorrelationId field for client-side error reporting and support ticket correlation

#### 9.5 File System JSON Cache Architecture

**Unified Cache Strategy**: JSON files on disk serve as the operational "database" for both Phase 1 and Phase 2

**Phase 1 (Kiosk) - Manual Curation:**
- Museum staff curates JSON files offline
- Files deployed with application (data/ directory)
- Read-only operation - no writes during kiosk runtime

**Phase 2 (Web) - MuseumPlus Synchronization:**
- Background sync job reads from MuseumPlus API
- Writes JSON files to disk cache (data/ directory)
- API endpoints serve from cache (identical to Phase 1)
- Sync uses atomic write operations to prevent corruption

**Atomic Write Strategy (Phase 2 only):**
- Write to temporary file: `{target}.tmp.{guid}`
- Atomic rename: `File.Move(temp, target, overwrite: true)`
- Cleanup on failure: Try-catch deletes temp file
- Thread-safe: Readers use FileShare.Read for concurrent access

**Repository Implementation:**
- Phase 1: Direct file reads with `JsonSerializer.DeserializeAsync`
- Phase 2: Same file reads - sync job handles writes separately
- No difference in repository code between phases

**File System Structure Decision: Flat vs. Nested**

**Chosen Structure - Flat Collections:**
```
data/sample/
├── studios/
│   ├── mate-lajos-dombovar.json
│   └── studio-2.json
├── images/
│   ├── f41074.json  (contains studioId reference)
│   ├── f41159.json
│   └── f41160.json
└── manifests/
    └── studios-manifest.json
```

**Alternative Considered - Nested Hierarchy:**
```
data/sample/
├── studios/
│   ├── mate-lajos-dombovar/
│   │   ├── studio.json
│   │   └── images/
│   │       ├── f41074.json
│   │       └── f41159.json
```

**Decision Rationale:**

**Primary Justification - MuseumPlus API Alignment:**
- MuseumPlus API returns XML with flat collections (verified via API documentation)
- Search results return iterable collections where relationships are expressed via ID references, not nested hierarchies
- Phase 2 sync mapping: XML flat collection → JSON flat collection (trivial transformation)
- Nested structure would require: XML flat collection → JSON nested hierarchy (complex reconstruction logic)
- Sync complexity avoided by matching source data structure

**Secondary Benefits:**
1. **Simpler repository code** - Single directory scan for `GetAllImages()`, direct file path construction for ID lookups
2. **Better Phase 2 CMS integration** - React Admin expects flat entity collections for CRUD operations
3. **Consistent with relational design** - Image files contain `studioId` foreign key reference (standard practice, not denormalization)

**Trade-offs Accepted:**
- Less intuitive for developers browsing filesystem manually (developer convenience, not operational requirement)

**Key Insights from Requirements Analysis:**

1. **Studio context always present in UI** - All realistic image queries include studio context (e.g., "show images for THIS studio"), making cross-studio queries without context unrealistic for this domain

2. **No manual file curation workflow** - Phase 1 receives pre-curated dataset, Phase 2 auto-syncs from MuseumPlus → filesystem "ease of browsing" serves developer debugging only, not operational workflow

3. **Museum collections are append-only** - Deletion scenarios (studio removal, orphaned images) are unrealistic → atomic deletion and orphan cleanup are non-requirements

4. **Avoid complexity that doesn't serve Phase 2** - Architectural decisions must consider Phase 2 MuseumPlus integration complexity, not theoretical flexibility

**MuseumPlus API Characteristics (Research Findings):**
- Returns XML, not JSON (requires XML-to-JSON conversion in sync job)
- Search results are flat iterables, not nested documents
- Relationships maintained through module references and ID fields
- Object structure: flat dictionary with accessible fields after xmltodict conversion

**Impact on Implementation:**
- Repository methods like `GetImagesByStudioId()` filter by studioId field (simple LINQ query)
- Phase 2 sync job reads MuseumPlus XML, converts to JSON, writes to same flat structure Phase 1 uses
- No repository code changes between Phase 1 and Phase 2

#### 9.6 Docker Multi-Architecture Build Setup
**Build Strategy**: Multi-stage Dockerfile with build-time platform argument resolution
- **Stage 1 (Build)**: Uses mcr.microsoft.com/dotnet/sdk:10.0-preview with --platform=$BUILDPLATFORM for native-speed compilation
- **Stage 2 (Runtime)**: Uses mcr.microsoft.com/dotnet/aspnet:10.0-preview runtime-only image for minimal attack surface (225MB amd64, 256MB arm64)
- **Architecture Targeting**: `dotnet restore -a $TARGETARCH` and `dotnet publish -a $TARGETARCH` enable cross-compilation

**Build Commands**:
```bash
# x64/AMD64 for PC deployment
docker build --platform linux/amd64 -t bffmini:amd64 .

# ARM64 for Raspberry Pi 5 deployment
docker build --platform linux/arm64 -t bffmini:arm64 .
```

**Security Hardening**:
- **Non-root User**: Creates and switches to `bffmini` user (UID 1000) before container startup
- **Directory Permissions**: Explicit chmod 755 on /app/data and /app/logs directories
- **Health Check**: curl-based endpoint validation every 30 seconds for orchestration-aware deployment
- **Port Configuration**: Exposes port 8080 (non-privileged) with ASPNETCORE_URLS environment variable

**Environment Variables**:
- **ASPNETCORE_ENVIRONMENT**: Controls configuration file selection (Development/Production)
- **ASPNETCORE_URLS**: Binds to http://+:8080 for container networking
- **DOTNET_RUNNING_IN_CONTAINER**: Enables container-aware runtime optimizations

#### 9.7 Security Configuration and Middleware
**CORS Policy**: Configured with fail-fast validation in Program.cs
- **Allowed Origins**: Environment-specific configuration (localhost:3000, localhost:5173 in development)
- **Methods & Headers**: AllowAnyMethod() and AllowAnyHeader() for flexibility during development
- **Credentials**: AllowCredentials() enabled for future authentication support
- **Fail-Fast Validation**: Application throws InvalidOperationException at startup if CORS origins are not configured, preventing misconfiguration in production

```csharp
var allowedOrigins = builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>()
    ?? throw new InvalidOperationException("CORS AllowedOrigins must be configured");
```

**Swagger/OpenAPI Configuration**: Development-only API documentation
- **Development**: Enabled at `/swagger` endpoint for local testing and development
- **Production**: Disabled to prevent API schema exposure and reduce attack surface
- **Documentation**: Auto-generated from minimal API endpoint definitions using Swashbuckle.AspNetCore

```csharp
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
```

**Health Checks**: Basic health endpoint at `/health`
- **Purpose**: Container orchestration readiness and liveness probes
- **Response**: HTTP 200 OK with "Healthy" text response
- **Integration**: Used by Docker health check and future Kubernetes/load balancer configurations

**Graceful Shutdown**: Application lifecycle management
- **Implementation**: IHostApplicationLifetime.ApplicationStopping registration
- **Behavior**: Logs shutdown event and allows in-flight requests to complete
- **Timeout**: Default 5-second grace period before forceful termination

#### 9.8 Data Models and Schema

**Entity Structure**: JSON-based data models following museum data structure from MuseumPlus integration

**Studio Entity** (`backend/BffMini/Models/Studio.cs`):
- **ID**: Unique identifier separate from inventory numbers (e.g., "mate-lajos-dombovar")
- **Photographer**: Name (bilingual), birth year, death year
- **Studio Address**: Street, city, geographic location
- **Operating Period**: Start year, end year
- **Characteristics**: Signature style, backdrop description, specialties
- **Collection**: Total images, inventory range (start/end numbers)
- **Catchment Area**: Array of location names where photographer worked

**Image Entity** (`backend/BffMini/Models/Image.cs`):
- **ID**: Unique identifier separate from inventory numbers (e.g., "f41074")
- **Studio ID**: Reference to parent studio
- **Inventory Number**: Museum inventory reference (e.g., "F41074")
- **Museum Catalog Number**: Full catalog reference (e.g., "NM F 41074")
- **Title & Description**: Bilingual text describing the photograph
- **Shooting Location**: Place name and optional coordinates (WHERE photo was taken, distinct from studio location)
- **Date Taken**: Year, year range, or precision indicator (exact/approximate/decade)
- **Technical Metadata**: Medium (glass negative), format (black-white), dimensions
- **Subjects**: Array of keyword tags for categorization
- **Photographer Signature Visible**: Boolean indicating if signature appears in image

**Supporting Models**:
- **BilingualText**: Hungarian (required) and English (optional) text fields
- **Location**: Place name, latitude/longitude with Hungary boundary validation (45.7°-48.6° N, 16.1°-22.9° E)
- **Manifest**: Ordering and metadata for Studios and Images collections

**Key Design Decisions**:
1. **Separate ID from Inventory Numbers**: Internal IDs for routing vs. museum catalog numbers for preservation
2. **Bilingual Throughout**: All user-facing text supports Hungarian/English
3. **Studio vs. Photo Location**: Studio has base address; each photo has shooting location (traveling photographer pattern)
4. **Date Flexibility**: Support exact years, ranges, and precision indicators for historical uncertainty
5. **Geographic Validation**: Coordinates validated to Hungary boundaries to prevent data entry errors

**JSON Schema Validation**: Schema files in `data/schemas/` provide validation rules:
- `studio-schema.json`: Studio entity validation with semantic versioning
- `image-schema.json`: Image entity validation
- `manifest-schema.json`: Manifest file validation for ordering/metadata

**Sample Data**: Reference implementations in `data/sample/`:
- Studios: `mate-lajos-dombovar.json` (based on Máté Lajos photographer from Dombóvár)
- Images: `f41074.json`, `f41159.json` (example photographs from collection)
- Manifests: `studios-manifest.json` (ordering and featured flags)

**Schema Evolution Strategy**:
- Semantic versioning in all entity `version` fields (default "1.0.0")
- Backward-compatible field additions supported
- Breaking changes require new schema version and migration path
- Schema files provided for reference and future validation implementation
- Validation currently handled at data entry level (manual curation for Phase 1, CMS for Phase 2)

#### 9.9 REST API Endpoints Specification

**Base URL**: `/api`

**Studios Endpoints** (`backend/BffMini/Endpoints/StudiosEndpoints.cs`):

**GET /api/studios**
- **Purpose**: Retrieve all photography studios
- **Response**: 200 OK with array of StudioDto
- **Error Handling**: 500 Internal Server Error on file system failures
- **Performance**: <200ms response time for typical 70-80 studios
- **Example Response**:
```json
[
  {
    "id": "mate-lajos-dombovar",
    "photographerNameHu": "Máté Lajos",
    "photographerNameEn": "Lajos Máté",
    "cityHu": "Dombóvár",
    "cityEn": "Dombóvár",
    "operatingStartYear": 1895,
    "operatingEndYear": 1920
  }
]
```

**GET /api/studios/{id}**
- **Purpose**: Retrieve a specific studio by ID
- **Parameters**: `id` - Studio identifier (e.g., "mate-lajos-dombovar")
- **Response**: 200 OK with StudioDto, 404 Not Found if studio doesn't exist
- **Error Handling**: 500 Internal Server Error on file system failures
- **Example Request**: `GET /api/studios/mate-lajos-dombovar`

**GET /api/studios/city/{city}**
- **Purpose**: Filter studios by city name (Hungarian or English)
- **Parameters**: `city` - City name (case-insensitive)
- **Response**: 200 OK with array of StudioDto (empty array if no matches)
- **Example Request**: `GET /api/studios/city/Dombóvár`

**Images Endpoints** (`backend/BffMini/Endpoints/ImagesEndpoints.cs`):

**GET /api/images**
- **Purpose**: Retrieve all images
- **Response**: 200 OK with array of ImageDto
- **Error Handling**: 500 Internal Server Error on file system failures
- **Performance**: <200ms response time for typical 3000+ images
- **Example Response**:
```json
[
  {
    "id": "f41074",
    "studioId": "mate-lajos-dombovar",
    "inventoryNumber": "F41074",
    "titleHu": "Férfi portré",
    "titleEn": "Male portrait",
    "dateTakenYear": 1910
  }
]
```

**GET /api/images/{id}**
- **Purpose**: Retrieve a specific image by ID
- **Parameters**: `id` - Image identifier (e.g., "f41074")
- **Response**: 200 OK with ImageDto, 404 Not Found if image doesn't exist
- **Error Handling**: 500 Internal Server Error on file system failures
- **Example Request**: `GET /api/images/f41074`

**GET /api/images/studio/{studioId}**
- **Purpose**: Retrieve all images for a specific studio
- **Parameters**: `studioId` - Studio identifier
- **Response**: 200 OK with array of ImageDto (empty array if no matches)
- **Example Request**: `GET /api/images/studio/mate-lajos-dombovar`

**Manifest Endpoints** (`backend/BffMini/Endpoints/ManifestEndpoints.cs`):

**GET /api/manifests/studios**
- **Purpose**: Retrieve ordered list of all studio IDs for display
- **Response**: 200 OK with array of studio IDs in display order
- **Error Handling**: Returns empty array if manifest file missing
- **Example Response**: `["mate-lajos-dombovar", "studio-2", "studio-3"]`

**GET /api/manifests/studios/{studioId}**
- **Purpose**: Retrieve ordered list of image IDs for a specific studio's gallery
- **Parameters**: `studioId` - Studio identifier
- **Response**: 200 OK with ManifestDto, 404 Not Found if manifest doesn't exist
- **Example Response**:
```json
{
  "studioId": "mate-lajos-dombovar",
  "imageIds": ["f41074", "f41159"],
  "updatedAt": "2025-10-15T00:00:00Z"
}
```

**HTTP Status Codes**:
- **200 OK**: Successful retrieval (single entity or collection)
- **404 Not Found**: Entity not found (applies to specific ID lookups only, not collections)
- **500 Internal Server Error**: File system errors, JSON deserialization failures

**CORS Configuration**:
- **Allowed Origins**: Configured per environment (localhost:3000, localhost:5173 for development)
- **Methods**: All methods allowed
- **Headers**: All headers allowed
- **Credentials**: Enabled for future authentication support

**Request/Response Logging**:
- **Correlation IDs**: Each request receives a unique correlation ID from HttpContext.TraceIdentifier
- **Structured Logging**: Serilog captures request/response metadata (method, path, status code, duration)
- **Performance Tracking**: Response times logged for performance monitoring

**Error Response Format**:
```json
{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.6.1",
  "title": "Error retrieving studio",
  "status": 500,
  "traceId": "00-abc123-def456-00"
}
```

**Data Transfer Objects (DTOs)**:
- **StudioDto**: Flattened structure from Studio model with bilingual fields exposed separately
- **ImageDto**: Flattened structure from Image model with bilingual fields exposed separately
- **ManifestDto**: Simplified manifest structure containing only essential ordering data

**API Design Principles**:
1. **RESTful Conventions**: Resource-based URLs, appropriate HTTP verbs, standard status codes
2. **Minimal API Pattern**: .NET minimal APIs for reduced boilerplate and improved performance
3. **Repository Pattern**: Clean separation between endpoints and data access logic
4. **Business-Focused Operations**: Repository methods express domain intent (GetStudiosByCity) not file operations
5. **Error Handling**: Graceful degradation with appropriate status codes and error messages
6. **Performance**: Singleton repository registration for efficient concurrent access

**Repository Layer** (`backend/BffMini/Repositories/`):

**IStudioRepository**:
- `GetAllStudiosAsync()`: Load all studios from JSON files
- `GetStudioByIdAsync(string id)`: Load specific studio, returns null if not found
- `GetStudiosByCityAsync(string city)`: Filter studios by city name (case-insensitive)

**IImageRepository**:
- `GetAllImagesAsync()`: Load all images from JSON files
- `GetImageByIdAsync(string id)`: Load specific image, returns null if not found
- `GetImagesByStudioIdAsync(string studioId)`: Filter images by studio ID

**IManifestRepository**:
- `GetStudioManifestAsync(string studioId)`: Load image ordering manifest for studio
- `GetStudioListAsync()`: Load ordered list of all studio IDs

**Repository Implementation Details**:
- **File Path Configuration**: Injected via IConfiguration (DataPaths:Studios, DataPaths:Images, DataPaths:Manifests)
- **JSON Deserialization**: System.Text.Json with case-insensitive property matching
- **Error Handling**: FileNotFoundException returns null, JSON errors logged and return null, other exceptions propagate
- **Thread Safety**: Stateless design with singleton registration enables concurrent requests
- **Logging**: Structured logging with file paths, entity counts, and error details

**Testing Coverage**:
- **Repository Unit Tests**: 6 tests per repository with file system mocking
- **Integration Tests**: 18 endpoint tests using CustomWebApplicationFactory
- **Test Organization**: Separate test classes for Studios, Images, and Manifest endpoints
- **Coverage**: 100% endpoint coverage, 95%+ repository method coverage

#### 9.10 CI/CD Pipeline and Testing Infrastructure

**GitHub Actions Workflows**: Automated testing, building, and deployment pipeline

**Backend CI Workflow** (`.github/workflows/backend-ci.yml`):
- **Trigger**: Push to main branch or pull requests affecting backend code
- **Setup**: .NET 10.0 SDK with preview quality flag
- **Steps**:
  1. Restore dependencies with `dotnet restore`
  2. Build in Release configuration with `--no-restore`
  3. Run tests with XPlat Code Coverage collection
  4. Generate HTML and Cobertura coverage reports using ReportGenerator
  5. Post coverage summary as PR comment
  6. Upload coverage artifacts for review
  7. Enforce 80% minimum coverage threshold (fails build if below)
- **Coverage Tools**: Coverlet collector (6.0.4) + ReportGenerator GitHub Action (5.3.11)
- **Report Formats**: HtmlInline, Cobertura, MarkdownSummaryGithub

**Docker Build Workflow** (`.github/workflows/backend-docker.yml`):
- **Trigger**: Push to main or pull requests affecting backend code
- **Multi-Architecture Support**: Builds for linux/amd64 and linux/arm64 platforms
- **Registry**: GitHub Container Registry (ghcr.io)
- **Build Process**:
  1. Set up QEMU for multi-platform emulation
  2. Configure Docker Buildx for advanced build capabilities
  3. Authenticate to GHCR using GITHUB_TOKEN
  4. Extract metadata and generate tags (branch, PR, semver, SHA, latest)
  5. Build and push multi-architecture images with layer caching
  6. Run Trivy vulnerability scanner on built images
  7. Upload security scan results to GitHub Security tab
- **Caching Strategy**: GitHub Actions cache (type=gha) for faster builds
- **Security Scanning**: Trivy generates SARIF format reports uploaded to CodeQL

**Docker Compose Configuration**:

**Production Configuration** (`backend/docker-compose.yml`):
- **Service**: Single bffmini service with multi-architecture build support
- **Networking**: Bridge network (bffmini-network) for isolation
- **Volumes**:
  - `./data:/app/data:ro` - Read-only data directory
  - `bffmini-logs:/app/logs` - Persistent log storage
- **Health Check**: curl-based endpoint validation at `/health` (30s interval)
- **Environment**: Production mode with ASPNETCORE_ENVIRONMENT=Production
- **Port Mapping**: 8080:8080 for HTTP traffic
- **Restart Policy**: unless-stopped for automatic recovery

**Development Override** (`backend/docker-compose.override.yml`):
- **Environment**: Development mode with enhanced logging
- **Volume Mounting**: Source code mounted for debugging
- **Purpose**: Local development testing without rebuilding containers

**Performance Testing Infrastructure** (`backend/BffMini.Tests/Performance/`):

**PerformanceTests.cs**:
- **Performance Requirements**: Gallery loading <2s, animations 60fps
- **Test Coverage**:
  1. `GetStudioImagesManifest_MeetsPerformanceRequirement()` - Validates manifest endpoint <2s
  2. `GetStudio_MeetsPerformanceRequirement()` - Validates studio endpoint <500ms
  3. `GetImage_MeetsPerformanceRequirement()` - Validates image endpoint <500ms
  4. `GetAllStudios_MeetsPerformanceRequirement()` - Validates studios list <2s
  5. `MultipleRequests_ConsistentPerformance()` - Theory test validating consistent performance over 10 iterations
- **Measurement**: Stopwatch-based timing with assertion thresholds
- **Metrics**: Average response time and maximum response time validation
- **Integration**: Uses CustomWebApplicationFactory for realistic environment

**Test Organization**:
```
backend/BffMini.Tests/
├── Models/
│   └── ModelSerializationTests.cs        # JSON serialization validation
├── Repositories/
│   ├── StudioRepositoryTests.cs          # File system mocking tests
│   └── ImageRepositoryTests.cs           # File system mocking tests
├── Integration/
│   ├── CustomWebApplicationFactory.cs    # Test server infrastructure
│   ├── StudiosEndpointTests.cs           # Studios API integration tests
│   ├── ImagesEndpointTests.cs            # Images API integration tests
│   └── ManifestTests.cs                  # Manifest API integration tests
└── Performance/
    └── PerformanceTests.cs               # Response time validation tests
```

**CI/CD Integration Benefits**:
1. **Automated Quality Gates**: All tests must pass before merge to main
2. **Coverage Enforcement**: 80% minimum threshold prevents regression
3. **Multi-Architecture Validation**: Ensures ARM64 and x64 builds both succeed
4. **Security Scanning**: Trivy catches vulnerabilities before deployment
5. **Fast Feedback**: PR comments show coverage impact immediately
6. **Deployment Confidence**: Performance tests validate <2s requirement continuously

**Local Development Workflow**:
```bash
# Run tests locally with coverage
cd backend
dotnet test --collect:"XPlat Code Coverage"

# Start development environment
docker-compose up

# Build multi-architecture images
docker build --platform linux/amd64 -t bffmini:amd64 backend/BffMini
docker build --platform linux/arm64 -t bffmini:arm64 backend/BffMini
```

**Deployment Pipeline** (Future):
- **Phase 1 (Kiosk)**: Docker image deployed to Raspberry Pi 5 with health monitoring
- **Phase 2 (Web)**: Blue-green deployment with automatic rollback on health check failures
- **Monitoring**: Integration with chosen observability stack (ELK/Grafana/Azure AppInsights)

#### 9.11 Frontend Project Structure and Architecture

**React 18 + TypeScript + Vite Setup**: Modern frontend build system with hot module replacement and optimized production builds

**Project Structure:**
```
frontend/
├── package.json                       # Dependencies and build scripts
├── tsconfig.json                      # TypeScript strict mode configuration with path aliases
├── vite.config.ts                     # Vite build configuration with PWA plugin
├── index.html                         # Application entry point
├── .env.example                       # Environment variable template
├── .env.development                   # Development environment configuration
├── public/
│   └── robots.txt                     # Search engine directives (manifest.webmanifest auto-generated by Vite PWA plugin)
└── src/
    ├── main.tsx                       # React 18 createRoot entry point
    ├── App.tsx                        # Root application component
    ├── vite-env.d.ts                  # Vite environment type definitions
    ├── components/                    # React components (organized by feature)
    ├── hooks/                         # Custom React hooks
    ├── utils/                         # Utility functions
    ├── types/                         # TypeScript type definitions
    │   └── index.ts                   # Global types (Studio, Image, Language, Theme)
    ├── config/
    │   └── api.ts                     # API configuration and fetch wrapper
    ├── styles/                        # CSS files and theme variables
    │   └── index.css                  # Global styles and CSS reset
    ├── contexts/                      # React Context providers
    └── test/
        └── setup.ts                   # Vitest test configuration
```

**Build Tool Configuration:**
- **Vite**: Modern build tool replacing Create React App for 10x faster development server startup
- **Hot Module Replacement (HMR)**: Instant UI updates without full page reload during development
- **Production Optimization**: Tree-shaking, minification, code splitting, and gzip compression
- **Multi-Architecture Support**: Build outputs support both Raspberry Pi ARM64 and PC x64 deployments

**TypeScript Configuration:**
- **Strict Mode**: Enabled with `noUnusedLocals`, `noUnusedParameters`, `noFallthroughCasesInSwitch`, `noUncheckedIndexedAccess`
- **Path Aliases**: Clean imports using `@/` prefix for all source directories
  - `@/components`, `@/hooks`, `@/utils`, `@/types`, `@/config`, `@/styles`, `@/contexts`
- **Module Resolution**: Bundler mode optimized for Vite with ES2020 target
- **Test Exclusion**: Test files excluded from production build via tsconfig `exclude` property

**API Integration:**
- **Centralized Configuration**: `src/config/api.ts` provides unified API endpoint definitions
- **BFF-Mini Integration**: Base URL configured via `VITE_API_BASE_URL` environment variable (default: http://localhost:8080)
- **Fetch Wrapper**: `apiFetch<T>()` helper with timeout handling, error boundaries, and TypeScript generics
- **Endpoint Map**: Type-safe endpoint builders for studios, images, and manifest endpoints

**PWA Configuration:**
- **Vite PWA Plugin**: Automated service worker generation for fullscreen kiosk mode
- **Manifest**: Fullscreen display mode for kiosk, landscape orientation, museum brand colors
- **Static Asset Caching**: Precaching of JS, CSS, HTML, images for instant page loads
- **Service Worker**: Auto-updates on new deployments, no API response caching (backend serves localhost efficiently)

**Testing Infrastructure:**
- **Vitest**: Modern test runner with native ESM support and Vite integration
- **React Testing Library**: Component testing with user-centric queries and interactions
- **Jest DOM**: Custom matchers for DOM assertions (`toBeInTheDocument`, etc.)
- **Test Setup**: Mocked `window.matchMedia` and `IntersectionObserver` for JSDOM environment
- **Coverage**: XPlat Code Coverage with configurable thresholds

**Development Workflow:**
```bash
# Install dependencies
cd frontend && npm install

# Start development server (http://localhost:5173)
npm run dev

# Run tests in watch mode
npm run test

# Run tests with coverage
npm run test:coverage

# Build for production
npm run build

# Preview production build
npm run preview
```

**TypeScript Type Definitions:**
- **Studio**: Studio entity with bilingual text, photographer, years active, image count
- **Image**: Image entity with bilingual metadata, thumbnails, full image URLs
- **StudioManifest**: Combined studio and images payload for gallery display
- **Language**: Union type `'hu' | 'en'` for bilingual content selection
- **Theme**: Union type `'light' | 'dark'` for dual theme system

**Environment Variables:**
- **VITE_API_BASE_URL**: BFF-Mini backend base URL (development: http://localhost:8080)
- **VITE_APP_NAME**: Application display name (VÁGATLANUL)

**Component Reusability Architecture:**
- **Phase 1 (Kiosk)**: Full-featured React application with touch-optimized UI components
- **Phase 2 (Web)**: Shared component library with responsive design additions
- **Design Tokens**: CSS variables enable consistent theming across platforms
- **Accessibility**: WCAG 2.1 AA compliance with proper ARIA labels and keyboard navigation

**Build Output Optimization:**
- **Code Splitting**: React vendor bundle separated for optimal caching (139KB gzipped)
- **Tree Shaking**: Unused code elimination via ES modules
- **Minification**: Terser for JavaScript, cssnano for CSS
- **Chunk Size Warning**: 1000KB threshold for performance monitoring

#### 9.12 Theme System with localStorage Persistence

**Purpose**: Dual light/dark theme support for enhanced user experience in varying exhibition lighting conditions, with preference persistence across sessions.

**Design Specification**: `docs/designs/design_20251010-163000.md` (Light/Dark dual theme specification)

**CSS Variable Architecture** (`frontend/src/styles/themes.css`):
- **Universal Variables**: Font families, touch target sizes, spacing, radius, shadows, transitions
- **Theme-Scoped Variables**: Background colors, surface colors, text colors, brand colors, focus rings
- **Theme Selection**: Applied via `data-theme` attribute on document root (`<html data-theme="light|dark">`)
- **Smooth Transitions**: All theme-aware properties transition with `var(--transition-base)` (0.3s ease)

**Color Palette**:

**Light Theme** (`:root[data-theme='light']`):
- Background: `#FEFCF7` (warm white)
- Surface: `#FFFFFF` (pure white)
- Text Primary: `#2D3748` (dark gray)
- Text Secondary: `#5A6C7D` (medium gray)
- Heritage Gold: `#D4AF74` (museum accent)
- Museum Deep Blue: `#1B365D` (primary brand)

**Dark Theme** (`:root[data-theme='dark']`):
- Background: `#1A1A1A` (near black)
- Surface: `#2C2C2C` (dark gray surface)
- Text Primary: `#E8E8E8` (light gray)
- Text Secondary: `#B0B0B0` (medium light gray)
- Heritage Gold: `#C9A461` (dimmed museum accent)
- Museum Deep Blue: `#3A5A8F` (lighter brand for readability)

**Global Styles** (`frontend/src/styles/globals.css`):
- **CSS Reset**: Modern reset with box-sizing, margin/padding normalization
- **Base Styles**: Document root applies theme variables with background and text colors
- **Typography**: Source Sans Pro font family with system fallbacks
- **Touch Optimization**: 64px minimum touch targets for kiosk displays
- **Accessibility**: `.sr-only` class for screen-reader-only content, `:focus-visible` support

**useTheme Hook** (`frontend/src/hooks/useTheme.ts`):

**API:**
```typescript
interface UseThemeReturn {
  theme: Theme;           // Current theme: 'light' | 'dark'
  setTheme: (theme: Theme) => void;  // Directly set theme
  toggleTheme: () => void;           // Toggle between light/dark
  isDark: boolean;                   // Convenience flag
}
```

**Features:**
1. **localStorage Persistence**: Theme preference saved to `theme` key, restored on mount
2. **System Preference Detection**: Falls back to `prefers-color-scheme: dark` media query when no saved preference exists
3. **Document Root Update**: Applies theme via `document.documentElement.setAttribute('data-theme', theme)`
4. **System Preference Listener**: Monitors system theme changes and updates automatically (only when user has no saved preference)
5. **Defensive Implementation**: Null checks for `window.matchMedia` ensure compatibility with test environments (JSDOM)

**Implementation Details:**
- **Initial State**: Checks localStorage → system preference → defaults to 'light'
- **State Management**: React `useState` with lazy initialization function
- **Side Effects**: Two `useEffect` hooks manage DOM updates and system preference listeners
- **Callbacks**: `useCallback` optimizations prevent unnecessary re-renders
- **Constants**: `THEME_STORAGE_KEY = 'theme'`, `THEME_ATTRIBUTE = 'data-theme'`

**ThemeToggle Component** (`frontend/src/components/ui/ThemeToggle.tsx`):

**Features:**
- **Visual Indicators**: Moon icon (🌙) for dark mode option, Sun icon (☀️) for light mode option
- **Text Labels**: "Dark" or "Light" text alongside icon for clarity
- **Touch-Optimized**: 64px height × 180px width button for kiosk displays
- **Keyboard Accessible**: Native `<button>` element supports Enter/Space keys
- **ARIA Compliant**: Dynamic `aria-label` describes action (e.g., "Switch to dark theme"), not current state

**Accessibility Implementation (WCAG 2.1 AA):**
- **aria-label**: Dynamically updated to describe the action ("Switch to [opposite theme] theme")
- **title Attribute**: Provides tooltip with same information as aria-label
- **aria-hidden="true"**: Icon span hidden from screen readers (redundant with label text)
- **type="button"**: Prevents accidental form submission when used in form contexts
- **Focus Visible**: Custom `:focus-visible` styles with 3px outline offset and brand color

**Visual Design:**
- **Hover Effect**: Gold border, subtle shadow, smooth transform
- **Active State**: Scale down animation for tactile feedback
- **Icon Size**: 24px × 24px for clear visibility
- **Spacing**: 12px gap between icon and label
- **Colors**: Inherits theme colors from CSS variables

**Animation and Performance:**
- **Transition Duration**: 0.3s ease for all theme-related color changes
- **Reduced Motion Support**: `@media (prefers-reduced-motion: reduce)` disables transitions
- **GPU Acceleration**: Transform properties for smooth animations
- **Will-Change**: Applied only during hover for performance optimization

**Testing Coverage:**

**useTheme Hook Tests** (`frontend/src/__tests__/hooks/useTheme.test.ts`):
1. Default theme initialization (light)
2. Document root attribute application
3. localStorage persistence on theme change
4. Theme restoration from localStorage on mount
5. Toggle from light to dark and vice versa
6. Direct theme setting via `setTheme`
7. System preference detection via `matchMedia`
8. Invalid localStorage value handling
9. Document attribute updates on theme changes
10. `isDark` flag accuracy

**ThemeToggle Component Tests** (`frontend/src/__tests__/components/ThemeToggle.test.tsx`):
1. Button rendering with correct role
2. Icon and label display in light mode
3. Icon and label display in dark mode
4. ARIA label for accessibility
5. Theme toggle on click interaction
6. Button content update after theme change
7. `type="button"` attribute validation
8. Title attribute for tooltip
9. Keyboard accessibility (button element type)
10. Dynamic ARIA label updates based on current theme

**Test Results**: 23/23 tests passing (10 hook tests + 10 component tests + 3 existing App tests)

**Integration with Application:**
- **App.tsx**: ThemeToggle component added to application header
- **Global Import**: `globals.css` imported in App.tsx for theme variable availability
- **Component CSS**: ThemeToggle.css imported within component for encapsulation
- **Theme Variables**: Existing components updated to use CSS variables (`--bg-color`, `--text-color`, etc.)

**Phase 1 (Kiosk) Behavior:**
- Theme toggle available in header for visitor preference
- Preference persists for exhibition session duration
- Default to light theme on first launch
- No network dependency for theme functionality

**Phase 2 (Web) Considerations:**
- Same theme system applies to online platform
- Mobile-responsive button sizing (reduce from 64px to 48px on small screens)
- Analytics tracking of theme preference usage (optional)
- SEO: No impact, theme applied client-side only

**Key Architectural Decisions:**

**Decision 1: CSS Variables over CSS-in-JS**
- **Rationale**: Native browser support, better performance, simpler debugging, framework-agnostic
- **Trade-off**: Less dynamic than CSS-in-JS, but sufficient for dual-theme system
- **Benefit**: Instant theme switching without React re-renders, 60fps animations

**Decision 2: localStorage over Cookies**
- **Rationale**: Client-side only (no server interaction), 10MB storage limit (vs 4KB cookies), simpler API
- **Trade-off**: Not sent with HTTP requests (not needed), requires JavaScript (acceptable for React app)
- **Benefit**: No backend coordination required, works offline in Phase 1

**Decision 3: System Preference Fallback**
- **Rationale**: Respects user's OS-level preference, better UX for first-time visitors
- **Trade-off**: Requires `window.matchMedia` support (99%+ browser compatibility)
- **Benefit**: Smart default before user explicitly sets preference

**Decision 4: Document Attribute over Class**
- **Rationale**: More semantic than class (`data-theme="dark"` vs `class="dark"`), clearer intent
- **Trade-off**: Slightly less familiar than class-based theming
- **Benefit**: Easier to query in tests, better separation from styling classes

**Performance Characteristics:**
- **Initial Load**: <5ms theme detection and application
- **Theme Switch**: <300ms visual transition (CSS transition duration)
- **localStorage Read/Write**: <1ms synchronous operations
- **Memory Impact**: Negligible (single event listener, no polling)
- **Re-render Optimization**: `useCallback` prevents unnecessary React re-renders

**Browser Compatibility:**
- **CSS Custom Properties**: All modern browsers (IE11 not supported, acceptable for 2026 deployment)
- **localStorage API**: Universal support
- **matchMedia API**: 99%+ browser support with graceful fallback
- **data-* Attributes**: Universal HTML5 support

**Future Extensibility:**
- **Additional Themes**: Easy to add high-contrast or sepia themes with new `data-theme` values
- **Theme Customization**: Could add accent color picker using same CSS variable architecture
- **Animation Preferences**: Could extend to respect `prefers-reduced-motion` more comprehensively
- **RTL Support**: CSS variables compatible with future right-to-left language support

**ARCHITECTURE SCOPE ENDS HERE**