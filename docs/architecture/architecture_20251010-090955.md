**ARCHITECTURE SUMMARY**

### 1. System Approach
**Architecture Pattern**: Backend-for-Frontend (BFF) with shared data layer - enables unified JSON schema supporting both offline kiosk and online web platform with component reusability
**Technology Categories**: .NET 10.0 backend + React 18 TypeScript frontend + JSON/SQLite data layer - latest LTS with performance improvements and native AOT support for museum applications
**Component Organization**: Dual BFF services (lightweight kiosk, full-featured web) consuming identical API contracts from shared JSON data structures with platform-specific optimizations

### 2. Phase Evolution Strategy
**Phase 1 (Kiosk)**: Docker containerized .NET mini-BFF serving static JSON files to React touch interface - simple offline operation with autonomous restart capabilities
**Phase 2 (Web)**: Enhanced .NET BFF with MuseumPlus API integration, write-through caching, and SQLite search indexing - adds horizontal scaling and CMS capabilities
**Long-term**: Modular architecture enables independent platform scaling, easy technology upgrades, and cost-effective hosting migration without architectural changes

### 3. System Structure
```
┌─────────────────┐    ┌─────────────────────────────────────┐
│   KIOSK APP     │    │           WEB PLATFORM              │
│   (React TS)    │    │          (React TS)                 │
│        │        │    │               │                     │
│   BFF-Mini      │    │           Web BFF                   │
│   (.NET 10)     │    │         (.NET 10)                   │
│        │        │    │        /          \                 │
│   JSON Files    │    │  JSON Cache    MuseumPlus API       │
│  (filesystem)   │    │ (filesystem)   (External)           │
└─────────────────┘    └─────────────────────────────────────┘
```

### 4. Key Architectural Decisions
**Decision 1**: .NET 10.0 ASP.NET Core backend - Latest LTS with support through 2027, excellent JSON handling with System.Text.Json improvements, native AOT compilation support for reduced memory footprint, enhanced ARM64 performance for Raspberry Pi deployment - Trade-off of preview version adoption (until November 2025 GA) for modern features and extended support timeline
**Decision 2**: React 18 TypeScript frontend - Component reusability between platforms, sophisticated animation capabilities (Framer Motion), type safety - Trade-off of learning curve for proven cultural heritage application framework
**Decision 3**: JSON filesystem + SQLite hybrid storage - Entity-level JSON files (one studio = one file, one image = one file) serve as primary data storage, SQLite FTS5 provides complementary search indexing for web platform only - Enables pure offline kiosk operation while providing <1 second web search queries - Trade-off of dual storage complexity for platform-specific optimization
**Decision 4**: Multi-architecture Docker deployment - Single codebase supporting Raspberry Pi 5 ARM64 and PC x64 with automated CI/CD - Trade-off of container overhead for deployment consistency and hardware flexibility

### 5. System Behavior Requirements
**Data Consistency**: Write-through caching with atomic JSON file updates and TTL-based cache invalidation - MuseumPlus API serves as source of truth with local filesystem providing offline resilience - Cache TTL configurable per entity type (default: 24 hours for studios, 1 hour for images), background refresh optional - Primary technology: .NET file I/O with temp-to-rename strategy
**Error Recovery**: Tiered fallback system with circuit breaker patterns - Kiosk operates independently, web serves cached content during API unavailability - Recovery technology: Polly retry policies with exponential backoff
**Audit & Compliance**: GDPR-compliant analytics and content access logging - 7-year retention for cultural heritage compliance - Google Analytics with consent management stored in SQLite audit tables
**Performance Expectations**: <2 second page loads, <200ms touch response, 100+ concurrent web users, <1 second search queries - Memory caching and CDN optimization for global image delivery - Horizontal scaling through load-balanced stateless .NET BFF instances with shared filesystem cache storage (NFS/Azure Blob Storage/AWS S3) for cache consistency across nodes
**Monitoring & Observability**: Minimum metrics tracking includes cache hit rate, MuseumPlus API latency, error rates, and request throughput - Technology choice configurable: ELK Stack (Elasticsearch/Logstash/Kibana), OpenTelemetry with Grafana, or Azure Application Insights depending on hosting environment - Structured logging with correlation IDs for distributed tracing across BFF instances

### 6. Integration & Extensibility
**System Boundaries**: MuseumPlus API integration with fallback caching, React Admin CMS for content management, email integration for visitor inquiries - HTTP REST protocols with bearer token authentication
**Extension Points**: Plugin architecture for additional content types, modular animation system for performance adaptation, configurable hosting options - React component composition and .NET dependency injection patterns
**Data Exchange**: Versioned JSON schema (semantic versioning) with bilingual content structure enabling backward-compatible field additions, image metadata with academic citation formats, Excel import pipeline - RESTful APIs with OpenAPI documentation for future integrations - Schema evolution supports new content types without breaking existing kiosk/web clients

### 7. Architectural Constraints & Assumptions
**System Boundaries**: Handles photo studio archive presentation and visitor interaction - does not manage physical collections, financial transactions, or complex user management beyond content editing roles
**Growth Assumptions**: 3000+ images expanding annually, peak 100+ concurrent web users, continuous 24/7 kiosk operation - architecture scales horizontally for web traffic and maintains offline reliability for exhibition use
**Technology Constraints**: Must support Raspberry Pi 5 ARM64 and legacy PC x64, integration with existing MuseumPlus system, limited post-launch support requiring maintainable technology choices

### 8. Testing Strategy
**Unit Testing Approach**: xUnit for .NET backend and Jest + React Testing Library for frontend - 95% coverage organized by feature slices within technical boundaries - Mock at API/database interfaces using Test Containers for integration testing
**E2E Testing Approach**: Playwright for cross-browser automation testing critical user journeys - 60-80% coverage of complete workflows from map interaction through image viewing - Test environment mirrors production with sample cultural heritage data
**Test Organization**: Vertical slice testing within frontend/backend layers, shared component testing across platforms, hardware-specific testing for touch interfaces - Agent-driven test automation with clear boundary definitions
**CI/CD Integration**: GitHub Actions pipeline with automated testing gates, multi-architecture Docker builds, blue-green deployment with automatic rollback capabilities - All tests must pass before deployment to prevent exhibition disruption

### 9. Implementation Details

#### 9.1 BFF-Mini Project Structure
```
backend/BffMini/
├── BffMini.csproj                   # .NET 10.0 project file with minimal dependencies
├── Program.cs                        # Minimal API entry point with middleware configuration
├── Dockerfile                        # Multi-architecture Docker build configuration
├── .dockerignore                     # Docker build exclusions
├── appsettings.json                  # Base configuration
├── appsettings.Development.json      # Development environment settings
├── appsettings.Production.json       # Production environment settings
├── Services/
│   ├── IJsonFileService.cs          # File service abstraction interface
│   └── JsonFileService.cs           # Atomic file operations implementation
├── Models/
│   └── ApiResponse.cs               # Standard API response wrapper with correlation ID
└── Extensions/
    └── ServiceCollectionExtensions.cs # Dependency injection configuration

backend/BffMini.Tests/
├── BffMini.Tests.csproj             # xUnit test project
├── Services/
│   └── JsonFileServiceTests.cs      # Unit tests with file system mocking
└── Integration/
    └── ApiIntegrationTests.cs       # Integration tests using WebApplicationFactory
```

#### 9.2 Dependency Injection Configuration
**Service Registration Pattern**: Extension method pattern in `ServiceCollectionExtensions.cs` provides clean separation of concerns and testability
- **IJsonFileService**: Registered as singleton for optimal performance - thread-safe design enables concurrent file access across requests
- **FileServiceOptions**: Configured via Options pattern binding to appsettings.json "FileService" section - supports environment-specific overrides
- **HTTP Context Accessor**: Registered for correlation ID propagation through request pipeline

**Configuration Binding**: Uses IOptions<T> pattern for strongly-typed configuration with validation support - enables runtime configuration reloads without application restart

#### 9.3 Logging Configuration and Correlation IDs
**Structured Logging**: Serilog configured with console and file sinks for comprehensive observability
- **Console Sink**: Formatted output for Docker container log aggregation with timestamp and log level
- **File Sink**: Rolling daily logs in logs/ directory with 30-day retention for troubleshooting
- **Enrichment**: FromLogContext + CorrelationId enricher automatically injects correlation IDs into all log entries

**Correlation ID Implementation**:
- **Source**: Uses HttpContext.TraceIdentifier as correlation ID - automatically generated per request by ASP.NET Core
- **Propagation**: Serilog request logging middleware enriches diagnostic context with CorrelationId property
- **Response Headers**: Correlation ID available in logs for request/response tracing and distributed system debugging
- **ApiResponse Model**: Includes CorrelationId field for client-side error reporting and support ticket correlation

#### 9.4 Atomic File Operations
**Temp-to-Rename Strategy**: JsonFileService implements atomic writes to prevent data corruption during concurrent access or system failures
- **Temp File Creation**: Writes to `{target}.tmp.{guid}` with exclusive file lock (FileShare.None)
- **Atomic Rename**: File.Move with overwrite=true provides atomic replacement on Linux filesystems
- **Cleanup**: Try-catch ensures temp files are deleted even on write failures
- **Read Safety**: Read operations use FileShare.Read allowing concurrent readers without blocking

**Path Security**: GetFullPath validation prevents directory traversal attacks by verifying resolved path remains within configured DataPath

#### 9.5 Docker Multi-Architecture Build Setup
**Build Strategy**: Multi-stage Dockerfile with build-time platform argument resolution
- **Stage 1 (Build)**: Uses mcr.microsoft.com/dotnet/sdk:10.0-preview with --platform=$BUILDPLATFORM for native-speed compilation
- **Stage 2 (Runtime)**: Uses mcr.microsoft.com/dotnet/aspnet:10.0-preview runtime-only image for minimal attack surface (225MB amd64, 256MB arm64)
- **Architecture Targeting**: `dotnet restore -a $TARGETARCH` and `dotnet publish -a $TARGETARCH` enable cross-compilation

**Build Commands**:
```bash
# x64/AMD64 for PC deployment
docker build --platform linux/amd64 -t bffmini:amd64 .

# ARM64 for Raspberry Pi 5 deployment
docker build --platform linux/arm64 -t bffmini:arm64 .
```

**Security Hardening**:
- **Non-root User**: Creates and switches to `bffmini` user (UID 1000) before container startup
- **Directory Permissions**: Explicit chmod 755 on /app/data and /app/logs directories
- **Health Check**: curl-based endpoint validation every 30 seconds for orchestration-aware deployment
- **Port Configuration**: Exposes port 8080 (non-privileged) with ASPNETCORE_URLS environment variable

**Environment Variables**:
- **ASPNETCORE_ENVIRONMENT**: Controls configuration file selection (Development/Production)
- **ASPNETCORE_URLS**: Binds to http://+:8080 for container networking
- **DOTNET_RUNNING_IN_CONTAINER**: Enables container-aware runtime optimizations

#### 9.6 Security Configuration and Middleware
**CORS Policy**: Configured with fail-fast validation in Program.cs
- **Allowed Origins**: Environment-specific configuration (localhost:3000, localhost:5173 in development)
- **Methods & Headers**: AllowAnyMethod() and AllowAnyHeader() for flexibility during development
- **Credentials**: AllowCredentials() enabled for future authentication support
- **Fail-Fast Validation**: Application throws InvalidOperationException at startup if CORS origins are not configured, preventing misconfiguration in production

```csharp
var allowedOrigins = builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>()
    ?? throw new InvalidOperationException("CORS AllowedOrigins must be configured");
```

**Swagger/OpenAPI Configuration**: Development-only API documentation
- **Development**: Enabled at `/swagger` endpoint for local testing and development
- **Production**: Disabled to prevent API schema exposure and reduce attack surface
- **Documentation**: Auto-generated from minimal API endpoint definitions using Swashbuckle.AspNetCore

```csharp
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
```

**Health Checks**: Basic health endpoint at `/health`
- **Purpose**: Container orchestration readiness and liveness probes
- **Response**: HTTP 200 OK with "Healthy" text response
- **Integration**: Used by Docker health check and future Kubernetes/load balancer configurations

**Graceful Shutdown**: Application lifecycle management
- **Implementation**: IHostApplicationLifetime.ApplicationStopping registration
- **Behavior**: Logs shutdown event and allows in-flight requests to complete
- **Timeout**: Default 5-second grace period before forceful termination

**ARCHITECTURE SCOPE ENDS HERE**