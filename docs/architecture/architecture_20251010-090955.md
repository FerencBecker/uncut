**ARCHITECTURE SUMMARY**

### 1. System Approach
**Architecture Pattern**: Backend-for-Frontend (BFF) with shared data layer - enables unified JSON schema supporting both offline kiosk and online web platform with component reusability
**Technology Categories**: .NET 8 backend + React 18 TypeScript frontend + JSON/SQLite data layer - proven stability for museum applications with excellent performance characteristics
**Component Organization**: Dual BFF services (lightweight kiosk, full-featured web) consuming identical API contracts from shared JSON data structures with platform-specific optimizations

### 2. Phase Evolution Strategy
**Phase 1 (Kiosk)**: Docker containerized .NET mini-BFF serving static JSON files to React touch interface - simple offline operation with autonomous restart capabilities
**Phase 2 (Web)**: Enhanced .NET BFF with MuseumPlus API integration, write-through caching, and SQLite search indexing - adds horizontal scaling and CMS capabilities
**Long-term**: Modular architecture enables independent platform scaling, easy technology upgrades, and cost-effective hosting migration without architectural changes

### 3. System Structure
```
┌─────────────────┐    ┌─────────────────────────────────────┐
│   KIOSK APP     │    │           WEB PLATFORM              │
│   (React TS)    │    │          (React TS)                 │
│        │        │    │               │                     │
│   BFF-Mini      │    │           Web BFF                   │
│   (.NET 8)      │    │         (.NET 8)                    │
│        │        │    │        /          \                 │
│   JSON Files    │    │  JSON Cache    MuseumPlus API       │
│  (filesystem)   │    │ (filesystem)   (External)           │
└─────────────────┘    └─────────────────────────────────────┘
```

### 4. Key Architectural Decisions
**Decision 1**: .NET 8 ASP.NET Core backend - Long-term support through 2026, excellent JSON handling, mature ecosystem for museum applications - Trade-off of Microsoft stack dependency for stability and performance
**Decision 2**: React 18 TypeScript frontend - Component reusability between platforms, sophisticated animation capabilities (Framer Motion), type safety - Trade-off of learning curve for proven cultural heritage application framework
**Decision 3**: JSON filesystem + SQLite hybrid storage - Entity-level JSON files (one studio = one file, one image = one file) serve as primary data storage, SQLite FTS5 provides complementary search indexing for web platform only - Enables pure offline kiosk operation while providing <1 second web search queries - Trade-off of dual storage complexity for platform-specific optimization
**Decision 4**: Multi-architecture Docker deployment - Single codebase supporting Raspberry Pi 5 ARM64 and PC x64 with automated CI/CD - Trade-off of container overhead for deployment consistency and hardware flexibility

### 5. System Behavior Requirements
**Data Consistency**: Write-through caching with atomic JSON file updates and TTL-based cache invalidation - MuseumPlus API serves as source of truth with local filesystem providing offline resilience - Cache TTL configurable per entity type (default: 24 hours for studios, 1 hour for images), background refresh optional - Primary technology: .NET file I/O with temp-to-rename strategy
**Error Recovery**: Tiered fallback system with circuit breaker patterns - Kiosk operates independently, web serves cached content during API unavailability - Recovery technology: Polly retry policies with exponential backoff
**Audit & Compliance**: GDPR-compliant analytics and content access logging - 7-year retention for cultural heritage compliance - Google Analytics with consent management stored in SQLite audit tables
**Performance Expectations**: <2 second page loads, <200ms touch response, 100+ concurrent web users, <1 second search queries - Memory caching and CDN optimization for global image delivery - Horizontal scaling through load-balanced stateless .NET BFF instances with shared filesystem cache storage (NFS/Azure Blob Storage/AWS S3) for cache consistency across nodes
**Monitoring & Observability**: Minimum metrics tracking includes cache hit rate, MuseumPlus API latency, error rates, and request throughput - Technology choice configurable: ELK Stack (Elasticsearch/Logstash/Kibana), OpenTelemetry with Grafana, or Azure Application Insights depending on hosting environment - Structured logging with correlation IDs for distributed tracing across BFF instances

### 6. Integration & Extensibility
**System Boundaries**: MuseumPlus API integration with fallback caching, React Admin CMS for content management, email integration for visitor inquiries - HTTP REST protocols with bearer token authentication
**Extension Points**: Plugin architecture for additional content types, modular animation system for performance adaptation, configurable hosting options - React component composition and .NET dependency injection patterns
**Data Exchange**: Versioned JSON schema (semantic versioning) with bilingual content structure enabling backward-compatible field additions, image metadata with academic citation formats, Excel import pipeline - RESTful APIs with OpenAPI documentation for future integrations - Schema evolution supports new content types without breaking existing kiosk/web clients

### 7. Architectural Constraints & Assumptions
**System Boundaries**: Handles photo studio archive presentation and visitor interaction - does not manage physical collections, financial transactions, or complex user management beyond content editing roles
**Growth Assumptions**: 3000+ images expanding annually, peak 100+ concurrent web users, continuous 24/7 kiosk operation - architecture scales horizontally for web traffic and maintains offline reliability for exhibition use
**Technology Constraints**: Must support Raspberry Pi 5 ARM64 and legacy PC x64, integration with existing MuseumPlus system, limited post-launch support requiring maintainable technology choices

### 8. Testing Strategy
**Unit Testing Approach**: xUnit for .NET backend and Jest + React Testing Library for frontend - 95% coverage organized by feature slices within technical boundaries - Mock at API/database interfaces using Test Containers for integration testing
**E2E Testing Approach**: Playwright for cross-browser automation testing critical user journeys - 60-80% coverage of complete workflows from map interaction through image viewing - Test environment mirrors production with sample cultural heritage data
**Test Organization**: Vertical slice testing within frontend/backend layers, shared component testing across platforms, hardware-specific testing for touch interfaces - Agent-driven test automation with clear boundary definitions
**CI/CD Integration**: GitHub Actions pipeline with automated testing gates, multi-architecture Docker builds, blue-green deployment with automatic rollback capabilities - All tests must pass before deployment to prevent exhibition disruption

**ARCHITECTURE SCOPE ENDS HERE**