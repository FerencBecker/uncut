**ARCHITECTURE SUMMARY**

### 1. System Approach
**Architecture Pattern**: Backend-for-Frontend (BFF) with shared data layer - enables unified JSON schema supporting both offline kiosk and online web platform with component reusability
**Technology Categories**: .NET 10.0 backend + React 18 TypeScript frontend + JSON/SQLite data layer - latest LTS with performance improvements and native AOT support for museum applications
**Component Organization**: Dual BFF services (lightweight kiosk, full-featured web) consuming identical API contracts from shared JSON data structures with platform-specific optimizations

### 2. Phase Evolution Strategy
**Phase 1 (Kiosk)**: Docker containerized .NET mini-BFF serving static JSON files to React touch interface - simple offline operation with autonomous restart capabilities
**Phase 2 (Web)**: Enhanced .NET BFF with MuseumPlus API integration, write-through caching, and SQLite search indexing - adds horizontal scaling and CMS capabilities
**Long-term**: Modular architecture enables independent platform scaling, easy technology upgrades, and cost-effective hosting migration without architectural changes

### 3. System Structure
```
┌─────────────────┐    ┌─────────────────────────────────────┐
│   KIOSK APP     │    │           WEB PLATFORM              │
│   (React TS)    │    │          (React TS)                 │
│        │        │    │               │                     │
│   BFF-Mini      │    │           Web BFF                   │
│   (.NET 10)     │    │         (.NET 10)                   │
│        │        │    │        /          \                 │
│   JSON Files    │    │  JSON Cache    MuseumPlus API       │
│  (filesystem)   │    │ (filesystem)   (External)           │
└─────────────────┘    └─────────────────────────────────────┘
```

### 4. Key Architectural Decisions
**Decision 1**: .NET 10.0 ASP.NET Core backend - Latest LTS with support through 2027, excellent JSON handling with System.Text.Json improvements, native AOT compilation support for reduced memory footprint, enhanced ARM64 performance for Raspberry Pi deployment - Trade-off of preview version adoption (until November 2025 GA) for modern features and extended support timeline
**Decision 2**: React 18 TypeScript frontend - Component reusability between platforms, sophisticated animation capabilities (Framer Motion), type safety - Trade-off of learning curve for proven cultural heritage application framework
**Decision 3**: JSON filesystem + SQLite hybrid storage - Entity-level JSON files (one studio = one file, one image = one file) serve as primary data storage, SQLite FTS5 provides complementary search indexing for web platform only - Enables pure offline kiosk operation while providing <1 second web search queries - Trade-off of dual storage complexity for platform-specific optimization
**Decision 4**: Multi-architecture Docker deployment - Single codebase supporting Raspberry Pi 5 ARM64 and PC x64 with automated CI/CD - Trade-off of container overhead for deployment consistency and hardware flexibility

### 5. System Behavior Requirements
**Data Consistency**: Write-through caching with atomic JSON file updates and TTL-based cache invalidation - MuseumPlus API serves as source of truth with local filesystem providing offline resilience - Cache TTL configurable per entity type (default: 24 hours for studios, 1 hour for images), background refresh optional - Primary technology: .NET file I/O with temp-to-rename strategy
**Error Recovery**: Tiered fallback system with circuit breaker patterns - Kiosk operates independently, web serves cached content during API unavailability - Recovery technology: Polly retry policies with exponential backoff
**Audit & Compliance**: GDPR-compliant analytics and content access logging - 7-year retention for cultural heritage compliance - Google Analytics with consent management stored in SQLite audit tables
**Performance Expectations**: <2 second page loads, <200ms touch response, 100+ concurrent web users, <1 second search queries - Memory caching and CDN optimization for global image delivery - Horizontal scaling through load-balanced stateless .NET BFF instances with shared filesystem cache storage (NFS/Azure Blob Storage/AWS S3) for cache consistency across nodes
**Monitoring & Observability**: Minimum metrics tracking includes cache hit rate, MuseumPlus API latency, error rates, and request throughput - Technology choice configurable: ELK Stack (Elasticsearch/Logstash/Kibana), OpenTelemetry with Grafana, or Azure Application Insights depending on hosting environment - Structured logging with correlation IDs for distributed tracing across BFF instances

### 6. Integration & Extensibility
**System Boundaries**: MuseumPlus API integration with fallback caching, React Admin CMS for content management, email integration for visitor inquiries - HTTP REST protocols with bearer token authentication
**Extension Points**: Plugin architecture for additional content types, modular animation system for performance adaptation, configurable hosting options - React component composition and .NET dependency injection patterns
**Data Exchange**: Versioned JSON schema (semantic versioning) with bilingual content structure enabling backward-compatible field additions, image metadata with academic citation formats, Excel import pipeline - RESTful APIs with OpenAPI documentation for future integrations - Schema evolution supports new content types without breaking existing kiosk/web clients

### 7. Architectural Constraints & Assumptions
**System Boundaries**: Handles photo studio archive presentation and visitor interaction - does not manage physical collections, financial transactions, or complex user management beyond content editing roles
**Growth Assumptions**: 3000+ images expanding annually, peak 100+ concurrent web users, continuous 24/7 kiosk operation - architecture scales horizontally for web traffic and maintains offline reliability for exhibition use
**Technology Constraints**: Must support Raspberry Pi 5 ARM64 and legacy PC x64, integration with existing MuseumPlus system, limited post-launch support requiring maintainable technology choices

### 8. Testing Strategy
**Unit Testing Approach**: xUnit for .NET backend and Jest + React Testing Library for frontend - 95% coverage organized by feature slices within technical boundaries - Mock at API/database interfaces using Test Containers for integration testing
**E2E Testing Approach**: Playwright for cross-browser automation testing critical user journeys - 60-80% coverage of complete workflows from map interaction through image viewing - Test environment mirrors production with sample cultural heritage data
**Test Organization**: Vertical slice testing within frontend/backend layers, shared component testing across platforms, hardware-specific testing for touch interfaces - Agent-driven test automation with clear boundary definitions
**CI/CD Integration**: GitHub Actions pipeline with automated testing gates, multi-architecture Docker builds, blue-green deployment with automatic rollback capabilities - All tests must pass before deployment to prevent exhibition disruption

### 9. Implementation Details

#### 9.1 BFF-Mini Project Structure

**Organization**: Feature-sliced vertical architecture
- **Repositories/**: Data access abstraction (IStudioRepository, IImageRepository, IManifestRepository)
- **Endpoints/**: Minimal API endpoints (StudiosEndpoints, ImagesEndpoints, ManifestEndpoints)
- **Models/**: Domain entities (Studio, Image, BilingualText, Location, Manifest)
- **Tests/**: xUnit tests organized by layer (Models/, Repositories/, Integration/, Performance/)

#### 9.2 Data Access Layer Architecture

**Repository Pattern**: Business-focused data access abstraction separating API endpoints from storage implementation details

**Layering:**
```
API Endpoints (REST operations: GET /api/studios?city=Dombovár)
    ↓
Repository Layer (business operations: GetAllStudios, GetStudiosByCity)
    ↓
File System (JSON files: data/studios/{id}.json)
```

**Phase 1 (Kiosk)**: Repository reads from manually curated JSON files on disk
**Phase 2 (Web)**: Repository reads from identical JSON files synchronized from MuseumPlus API
**Key Insight**: Same repository implementation serves both phases - only the source of JSON files changes

**Repository Responsibilities:**
- Load and deserialize JSON files into business objects (Studio, Image)
- Query and filter business objects (by city, by region, by date)
- Return business objects to API endpoints
- Handle file-not-found scenarios gracefully

#### 9.3 Dependency Injection Configuration
**Pattern**: Extension method in `ServiceCollectionExtensions.cs` - repositories as singletons (stateless), IOptions<T> for strongly-typed configuration

#### 9.4 Logging Configuration and Correlation IDs
**Implementation**: Serilog with console/file sinks, correlation IDs via HttpContext.TraceIdentifier, 30-day retention

#### 9.5 File System JSON Cache Architecture

**Unified Cache Strategy**: JSON files on disk serve as the operational "database" for both Phase 1 and Phase 2

**Phase 1 (Kiosk) - Manual Curation:**
- Museum staff curates JSON files offline
- Files deployed with application (data/ directory)
- Read-only operation - no writes during kiosk runtime

**Phase 2 (Web) - MuseumPlus Synchronization:**
- Background sync job reads from MuseumPlus API
- Writes JSON files to disk cache (data/ directory)
- API endpoints serve from cache (identical to Phase 1)
- Sync uses atomic write operations to prevent corruption

**Atomic Write Strategy (Phase 2 only):**
- Write to temporary file: `{target}.tmp.{guid}`
- Atomic rename: `File.Move(temp, target, overwrite: true)`
- Cleanup on failure: Try-catch deletes temp file
- Thread-safe: Readers use FileShare.Read for concurrent access

**Repository Implementation:**
- Phase 1: Direct file reads with `JsonSerializer.DeserializeAsync`
- Phase 2: Same file reads - sync job handles writes separately
- No difference in repository code between phases

**File System Structure Decision: Flat vs. Nested**

**Chosen Structure - Flat Collections:**
```
data/sample/
├── studios/
│   ├── mate-lajos-dombovar.json
│   └── studio-2.json
├── images/
│   ├── f41074.json  (contains studioId reference)
│   ├── f41159.json
│   └── f41160.json
└── manifests/
    └── studios-manifest.json
```

**Alternative Considered - Nested Hierarchy:**
```
data/sample/
├── studios/
│   ├── mate-lajos-dombovar/
│   │   ├── studio.json
│   │   └── images/
│   │       ├── f41074.json
│   │       └── f41159.json
```

**Decision Rationale:**

**Primary Justification - MuseumPlus API Alignment:**
- MuseumPlus API returns XML with flat collections (verified via API documentation)
- Search results return iterable collections where relationships are expressed via ID references, not nested hierarchies
- Phase 2 sync mapping: XML flat collection → JSON flat collection (trivial transformation)
- Nested structure would require: XML flat collection → JSON nested hierarchy (complex reconstruction logic)
- Sync complexity avoided by matching source data structure

**Secondary Benefits:**
1. **Simpler repository code** - Single directory scan for `GetAllImages()`, direct file path construction for ID lookups
2. **Better Phase 2 CMS integration** - React Admin expects flat entity collections for CRUD operations
3. **Consistent with relational design** - Image files contain `studioId` foreign key reference (standard practice, not denormalization)

**Trade-offs Accepted:**
- Less intuitive for developers browsing filesystem manually (developer convenience, not operational requirement)

**Key Insights from Requirements Analysis:**

1. **Studio context always present in UI** - All realistic image queries include studio context (e.g., "show images for THIS studio"), making cross-studio queries without context unrealistic for this domain

2. **No manual file curation workflow** - Phase 1 receives pre-curated dataset, Phase 2 auto-syncs from MuseumPlus → filesystem "ease of browsing" serves developer debugging only, not operational workflow

3. **Museum collections are append-only** - Deletion scenarios (studio removal, orphaned images) are unrealistic → atomic deletion and orphan cleanup are non-requirements

4. **Avoid complexity that doesn't serve Phase 2** - Architectural decisions must consider Phase 2 MuseumPlus integration complexity, not theoretical flexibility

**MuseumPlus API Characteristics (Research Findings):**
- Returns XML, not JSON (requires XML-to-JSON conversion in sync job)
- Search results are flat iterables, not nested documents
- Relationships maintained through module references and ID fields
- Object structure: flat dictionary with accessible fields after xmltodict conversion

**Impact on Implementation:**
- Repository methods like `GetImagesByStudioId()` filter by studioId field (simple LINQ query)
- Phase 2 sync job reads MuseumPlus XML, converts to JSON, writes to same flat structure Phase 1 uses
- No repository code changes between Phase 1 and Phase 2

#### 9.6 Docker Multi-Architecture Build Setup
**Strategy**: Multi-stage Dockerfile targeting linux/amd64 and linux/arm64, non-root user (UID 1000), health check, port 8080

#### 9.7 Security Configuration and Middleware
**CORS**: Fail-fast validation, environment-specific origins | **Swagger**: Development-only | **Health**: `/health` endpoint for orchestration | **Shutdown**: Graceful with 5s timeout

#### 9.8 Data Models and Schema

**Entity Structure**: JSON-based data models following museum data structure from MuseumPlus integration

**Studio Entity** (`backend/BffMini/Models/Studio.cs`):
- **ID**: Unique identifier separate from inventory numbers (e.g., "mate-lajos-dombovar")
- **Photographer**: Name (bilingual), birth year, death year
- **Studio Address**: Street, city, geographic location
- **Operating Period**: Start year, end year
- **Characteristics**: Signature style, backdrop description, specialties
- **Collection**: Total images, inventory range (start/end numbers)
- **Catchment Area**: Array of location names where photographer worked

**Image Entity** (`backend/BffMini/Models/Image.cs`):
- **ID**: Unique identifier separate from inventory numbers (e.g., "f41074")
- **Studio ID**: Reference to parent studio
- **Inventory Number**: Museum inventory reference (e.g., "F41074")
- **Museum Catalog Number**: Full catalog reference (e.g., "NM F 41074")
- **Title & Description**: Bilingual text describing the photograph
- **Shooting Location**: Place name and optional coordinates (WHERE photo was taken, distinct from studio location)
- **Date Taken**: Year, year range, or precision indicator (exact/approximate/decade)
- **Technical Metadata**: Medium (glass negative), format (black-white), dimensions
- **Subjects**: Array of keyword tags for categorization
- **Photographer Signature Visible**: Boolean indicating if signature appears in image

**Supporting Models**:
- **BilingualText**: Hungarian (required) and English (optional) text fields
- **Location**: Place name, latitude/longitude with Hungary boundary validation (45.7°-48.6° N, 16.1°-22.9° E)
- **Manifest**: Ordering and metadata for Studios and Images collections

**Key Design Decisions**:
1. **Separate ID from Inventory Numbers**: Internal IDs for routing vs. museum catalog numbers for preservation
2. **Bilingual Throughout**: All user-facing text supports Hungarian/English
3. **Studio vs. Photo Location**: Studio has base address; each photo has shooting location (traveling photographer pattern)
4. **Date Flexibility**: Support exact years, ranges, and precision indicators for historical uncertainty
5. **Geographic Validation**: Coordinates validated to Hungary boundaries to prevent data entry errors

**JSON Schema Validation**: Schema files in `data/schemas/` provide validation rules:
- `studio-schema.json`: Studio entity validation with semantic versioning
- `image-schema.json`: Image entity validation
- `manifest-schema.json`: Manifest file validation for ordering/metadata

**Sample Data**: Reference implementations in `data/sample/`:
- Studios: `mate-lajos-dombovar.json` (based on Máté Lajos photographer from Dombóvár)
- Images: `f41074.json`, `f41159.json` (example photographs from collection)
- Manifests: `studios-manifest.json` (ordering and featured flags)

**Schema Evolution Strategy**:
- Semantic versioning in all entity `version` fields (default "1.0.0")
- Backward-compatible field additions supported
- Breaking changes require new schema version and migration path
- Schema files provided for reference and future validation implementation
- Validation currently handled at data entry level (manual curation for Phase 1, CMS for Phase 2)

#### 9.9 REST API Endpoints Specification

**API Design**: RESTful endpoints at `/api` using .NET Minimal APIs with repository pattern abstraction

**Endpoints**:
- **Studios**: GET /api/studios, /api/studios/{id}, /api/studios/city/{city}
- **Images**: GET /api/images, /api/images/{id}, /api/images/studio/{studioId}
- **Manifests**: GET /api/manifests/studios, /api/manifests/studios/{studioId}

**Repositories**: IStudioRepository, IImageRepository, IManifestRepository - stateless singletons, file-based JSON loading, null returns for not-found

**Status Codes**: 200 OK, 404 Not Found (single entity), 500 Internal Server Error (file system/JSON errors)

**Full API documentation**: See Swagger at `/swagger` (development only)

#### 9.10 CI/CD Pipeline and Testing Infrastructure

**GitHub Actions**:
- **Backend CI**: .NET 10.0 restore/build/test, Coverlet + ReportGenerator, 80% coverage minimum, PR comments
- **Docker Build**: Multi-arch (amd64/arm64), GHCR push, Trivy security scanning, GitHub Actions cache

**Docker Compose**: Production config with health checks, read-only data volume, persistent logs | Development override for local testing

**Test Organization**: Models (serialization), Repositories (file mocking), Integration (WebApplicationFactory), Performance (<2s gallery, <500ms endpoints)

#### 9.11 Frontend Project Structure and Architecture

**Stack**: React 18 + TypeScript + Vite with HMR, PWA plugin for fullscreen kiosk mode

**TypeScript Config**: Strict mode, path aliases (`@/components`, `@/hooks`, etc.), ES2020 target, Vite bundler mode

**API Integration**: Centralized config in `src/config/api.ts`, BFF-Mini via `VITE_API_BASE_URL` env var

**Testing**: Vitest + React Testing Library + Jest DOM, mocked `matchMedia`/`IntersectionObserver` in setup

**Key Directories**: `components/` (features), `hooks/` (shared), `types/` (Studio, Image, Language, Theme), `styles/` (CSS variables), `locales/` (i18n), `test/` (setup)

**Build Output**: Tree-shaking, code splitting, Terser minification, vendor bundle ~139KB gzipped

#### 9.12 Theme System with localStorage Persistence

**Implementation**: CSS variables with dual light/dark theme for varying exhibition lighting conditions

**CSS Architecture** (`frontend/src/styles/themes.css`, `globals.css`):
- Universal variables: fonts, spacing, touch targets (64px min), radius, shadows
- Theme variables: backgrounds, surfaces, text, brand colors, focus rings
- Theme selection: `<html data-theme="light|dark">` with 0.3s transitions
- Light theme: warm white bg (#FEFCF7), heritage gold (#D4AF74), museum blue (#1B365D)
- Dark theme: near black bg (#1A1A1A), dimmed gold (#C9A461), lighter blue (#3A5A8F)

**useTheme Hook** (`frontend/src/hooks/useTheme.ts`):
- Returns: `theme`, `setTheme`, `toggleTheme`, `isDark`
- localStorage key: `theme` for persistence
- System preference detection: Falls back to `prefers-color-scheme: dark` media query
- Document update: `document.documentElement.setAttribute('data-theme', theme)`

**ThemeToggle Component** (`frontend/src/components/ui/ThemeToggle.tsx`):
- Icons: 🌙 (dark) / ☀️ (light) with text labels
- Touch-optimized: 64px height × 180px width
- ARIA compliant: dynamic `aria-label` describes action

**Key Decisions**:

**Decision 1: CSS Variables over CSS-in-JS**
- Rationale: Native support, better performance, framework-agnostic
- Benefit: Instant theme switching without React re-renders, 60fps animations

**Decision 2: localStorage over Cookies**
- Rationale: Client-side only, 10MB limit vs 4KB, simpler API
- Benefit: No backend coordination, works offline

**Decision 3: Document Attribute over Class**
- Rationale: More semantic (`data-theme="dark"` vs `class="dark"`)
- Benefit: Clearer intent, easier to query in tests

#### 9.13 Multi-Language System with localStorage Persistence

**Implementation**: react-i18next + i18next (~12KB gzipped) for bilingual Hungarian/English support

**Configuration** (`frontend/src/i18n.ts`):
- Default language: Hungarian (`'hu'`) with English fallback
- Translation files: `@/locales/hu.json`, `@/locales/en.json`
- localStorage key: `selectedLanguage` for persistence
- Auto-sync language changes to localStorage via `i18n.on('languageChanged')`

**Translation Function (`t()`):**
- Dot-notation keys (e.g., `'common.appTitle'`)
- Interpolation: `t('welcome', { name: 'User' })` → "Welcome, User"
- Pluralization: `t('items', { count: 5 })` → "5 items"
- Fallback: current lang → Hungarian → key

**Components**:
- **LanguageToggle** (`frontend/src/components/ui/LanguageToggle.tsx`): Flag icons (🇭🇺/🇬🇧), touch-optimized, shows opposite language
- **useTranslation Hook** (from react-i18next): Provides `i18n`, `t` function for translations

**Integration**:
- `@/i18n` imported in App.tsx for initialization
- Test setup imports `@/i18n` for all test access to translation functions
- BilingualText content from backend consumed via language selection

**Key Decisions**:

**Decision 1: react-i18next over Custom Implementation**
- Rationale: Industry-standard with interpolation and pluralization needed for museum content
- Trade-off: +12KB bundle vs homegrown solution
- Benefit: Professional i18n, saves development time, TypeScript support

**Decision 2: Toggle Shows Opposite Language**
- Rationale: Action-oriented UI (user sees what they'll get)
- Benefit: Clearer affordance, matches expected flag selection pattern

#### 9.14 Animation System with Framer Motion

**Implementation**: Framer Motion (~52KB gzipped) for 60fps kiosk animations with accessibility support

**Animation Utilities** (`frontend/src/utils/animations.ts`):
- Timing presets: fast (0.15s), base (0.2s), slow (0.3s)
- Variant generators: fade, slide (4 directions), scale, page transitions
- GPU-accelerated: transform and opacity properties only

**Components** (`frontend/src/components/animations/`):
- **FadeIn**, **SlideIn**, **ScaleIn**, **PageTransition**: Reusable animation wrappers with speed/delay config
- **useReducedMotion** hook: Detects `prefers-reduced-motion` and disables animations for accessibility

**Key Decisions**:

**Decision 1: Framer Motion over Custom CSS**
- Rationale: Industry-standard with React 18 integration, gesture support
- Trade-off: +52KB bundle vs custom CSS
- Benefit: Proven 60fps performance, saves development time

**Decision 2: Reduced Motion by Default**
- Rationale: WCAG 2.1 AA compliance
- Benefit: All animation components render static content when user prefers reduced motion

#### 9.15 Performance Monitoring and Error Boundaries

**Implementation**: Error recovery and performance tracking for 24/7 kiosk reliability

**Components**:
- **ErrorBoundary**: React error boundary with automatic retry (3 attempts, exponential backoff), correlation IDs (`err-{timestamp}-{random}`), Hungarian/English UI
- **usePerformanceMonitoring**: Hook tracking FPS (requestAnimationFrame), touch response (<200ms target), memory (Chrome API) with configurable thresholds
- **PerformanceMonitor**: Development-only dashboard (import.meta.env.DEV)

**Error Persistence**: Last 50 errors in sessionStorage (offline debugging without backend)

**Key Decision**: Class-based monitors (FPSMonitor, TouchResponseMonitor, MemoryMonitor) for state persistence independent of React lifecycle - Trade-off: OOP/functional mix vs pure hooks, but required for requestAnimationFrame control

**ARCHITECTURE SCOPE ENDS HERE**
